## 算法

​	设计并实现一种用计算机来解决问题的方法

​    输入： 有零个或者多个外部两作为算法的输入

​	输出：算法产生至少一个量作为输出

​	确定性： 组成算法的每条指令清晰、无歧义

​	有限性：算法中每条指定的执行次数有限，执行每条指令的时间也有限。





1. 问题的理解：清楚问题的输入，要求，输出
2. 数据结构设计：一方面要选择或设计能有效表示和存储应用问题中所涉及的数据结构对象的数据结构，同时还要选择或设计能支持算法策略实现的数据结构
3. 算法设计： 包括选择算法策略、用适当的方式描述和逐步细化算法步骤
4. 算法分析：发现有改进完善之处，返回第二部，重新选择或设计数据结构、重新设计算法。
5. 程序实现： 用某种计算机程序设计语言，定义数据结构、编写实现算法的代码，在计算机上调试和运行程序。

### 算法复杂度分析

​	N 表示问题的规模

​	I 表示算法的输入

​	A 表示算法本身

​	算法复杂度：$C = F(N,I,A)$

​	时间复杂度：$T = T(N,I)$

​	空间复杂度：$S = S(N,I)$

​	好的算法应具备的特性：

    1. 正确性： 正确性是对算法能否正确求解问题的评价，是首要和最基本的特性；
    2. 可读性：可读性是对算法描述的思路、层次的评价。好的算法应该是思路清晰、层次分明、阅读和修改容易；
    3. 健壮性：健壮性是对算法在异常情况下处理能力的评价。好的算法在出现异常或非法数据时，在操作不当时，算法都能做适当处理；
    4. 高效性：算法的效率是对求解同样问题的不同算法所占用的时间或空间的评价。好的算法应该是高效的，即求解问题所占用的存储空间少，执行时间短。

#### 复杂函数F具体化

​	设抽象的计算机所提供的元运算有K种，分别为 ${O_1}, $${O_2}$ ... ${O_k}$

​    又设每次执行一次这些元运算的时间分别为 ${t_1}$,${t_2}$...${t_k}$

​	对于算法A,设统计用到元运算${O_i}$ 的次数为$$ {e_i} $$

​    因此 ${e_i} = {e_i}(N,I)$ 时间复杂度为：$T(N,I) = \sum_{t=1}^{k}{t_i}{e_i}(N,I)$



#### 时间复杂度

​	一个算法中的语句执行次数（计算步） 称为语句频度或时间频度。记为$T(N)$

​	算法的基本操作重复执行的次数是模块N的某一个函数$f(n)$,因此: $T(n) = O(f(n))$

分析： 随着模块N的增大，算法执行的时间的增长率和 $f(n)$的增长率成正比，所以 $f(n)$越小，算法的时间复杂度越低，算法的效率越高.



##### 最坏时间复杂度

​	${T_{max}}(N)=\underbrace{max}_{I\in{D_n}}T(N,I)$ = $\underbrace{max}_{I\in{D_n}}\sum^k_{t=1}{t_i}{e_i}(N,{I^*})$ = $T(N,{I^*})$



##### 最好时间复杂度

​	${T_{min}}(N)$ = $\underbrace{min}_{I\in{D_N}}T(N,I)$ = $\underbrace{min}_{I\in{D_N}}\sum^k_{i=1}{t_i}{e_i}(N,I) = \sum^k_{i=1}{t_i}{e_i}(N,{\tilde{I}})$ 

##### 平均情况下的时间复杂度

​	$T\underbrace{avg}(N)$ = $\underbrace\sum_{I\in{D_n}}P(I)T(N,I)=\underbrace\sum_{I\in{D_N}}P(I)\underbrace\sum_{i=1}^k{t_i}{e_i}(N,I)$

其中 ${D_n}$是规模为N的合法输入的集合;${I^*}$是 ${D_n}$中使$T(N,{I^*})$达到${T_{max}}(N)$的合法输入，${\tilde{I}}$ 是使$T(N,{\tilde{I}})$达到${T_{min}}(N)$的合法输入；

而P(I)是在算法的应用中删除线输入I的概率



##### 渐进表达式

###### 渐进分析

​	复杂性渐进性态：

​		当N单调增加趋于$\infty$时，T(N)也单调增加趋于$\infty$ 

​		如果存在$\tilde{T}(N)$当N $\rightarrow$ $\infty$时有 $(T(N)-\tilde{T}(N))/T(N) \rightarrow 0$

​		那么称 $\tilde{T}(N)$ 是 T(N)的渐近性态

​		直观上$\tilde{T}(N)$ 是T(N)中略去低阶项所留下来的主项



###### 渐进分析的符号

​	在下面的讨论中，对所有 n, $f(n) \geq$ 0,$g(n) \geq 0$

​	(1) 渐进上界记号O

​			$O(g(n)) = {f(n)|存在正整数c和{n_0}使得对所有的 n \geq {n_0}有: 0 \leq f(n) <cg(n)}$

​	(2) 渐进下界符号 $\Omega$

​		$\Omega(g(n)) = {f(n)|存在正整数c和{n_0}是得对所有的 n \geq {n_0}有: 0 \leq cg(n) \leq f(n) }$

​	(3)紧渐进界记号

​		$\Theta(g(n)) = {f(n)|存在正整数 {c_1},{c_2}和 {n_0}使得对所有 n \geq {n_0}有: {c_1}g(n) \leq f(n) \leq {c_2}g(n)}$

​	(4) 非紧上界记号$o$

​		$o(g(n)) = {f(n) |对于任何正常数 c \gt 0,存在正数和 {n_0} \gt 0 使得对所有 n \ge {n_0}} 有: 0 \le f(n) \lt cg(n) 等价于 f(n) / g(n) \rightarrow 0 , n \rightarrow \infty $

​	(5) 非紧下界记号$\omega$

​		$\omega(g(n)) = {f(n)|对于任何正常数 c \gt 0,存在正数和 {n_0} \gt 0 使得对于所有的 n \ge {n_0} 有: 0 \le cg(n) \le f(n)} 等价于 f(n)/g(n) \rightarrow \infty ,  n \rightarrow \infty$



​	如果 $f(n)$是集合$O(g(n))$ 中的一个成员，我们说$f(n)$属于$O(g(n))$



###### 渐近分析中函数比较

​	$f(n) = O(g(n)) \rightarrow a \le b;$

​	$f(n) = \Omega(g(n)) \rightarrow a \ge b$

​	$f(n) = \Theta(g(n)) \rightarrow a = b$

​	$f(n) = o(g(n)) \rightarrow a \lt b$

​	$f(n) = \omega(g(n)) \rightarrow a \gt b$

###### 渐进分析的算术运算

​	$O(f(n)) + O(g(n)) = O(max{f(n),g(n)})$

​	$O(f(n)) + O(g(n)) = O(f(n) + g(n))$

​	$O(f(n) * O(g(n))) = O(f(n) * g(n))$

​	$O(cf(n)) = O(f(n))$

​	$g(n) = O(f(n))  \rightarrow O(f(n)) + O(g(n)) = O(f(n))$

常用关系式

​	多项式：$  {a_0} +{a_1}n + ... + {a_d}n^d = \Theta(n^d)$ 其中 ${a_d} \gt 0$

​	对数：$O({log_a}n) = O({log_b}n)$ 其中 $ a,b \gt 0 为常数$

​	对数：对于任意 $x \gt 0, {log_n} =O(n^x)$

​	指数：对于任意 $r \gt 1$ 和 $d \gt 0, n^d = O(r^n)$

###### 运用渐近分析计算计算机程序的时间复杂度



